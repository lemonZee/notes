## 持久化

#### 什么是持久化？

利用 永久性存储介质 将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。



#### Redis持久化的两种方式

1. RDB

    保存当前数据状态（快照形式）

   

2. AOF

   保存数据的操作过程（日志形式）



### RDB

##### save指令 

作用：手动执行一次保存操作

相关配置:

![1609730982029](.\images\1609730982029.png)



注意：save指令的执行会阻塞当前Redis服务器， 直到当前RDB过程完成为止， 有可能会造成长时间阻塞， **线上环境不建议使用。** 



##### bgsave指令

作用：手动启动后台保存操作，但不是立即执行 。

工作原理：

![1609731160111](.\images\1609731160111.png)

相关配置：

##### ![1609731253167](.\images\1609731253167.png)

**注意： bgsave命令是针对save阻塞问题做的优化。 Redis内部所有涉及到RDB操作都采用bgsave的方式， save命令可以放弃使用。**

![1609739312924](.\images\1609739312924.png)

**注意**：

save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的
save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系
save配置启动后执行的是**bgsave操作** 



##### RDB两种启动方式的对比

![1609739635003](.\images\1609739635003.png)

##### RDB特殊启动形式

1. 全量复制

2. 服务器运行过程中重启

   ```
   debug reload
   ```

3. 闭服务器时指定保存数据

```
shutdown save
```

如果没有开启AOF持久化功能，默认情况下执行shutdown命令时， 自动执行bgsave



##### 优点

1. RDB是一个紧凑压缩的二进制文件， 存储效率较高

2. RDB内部存储的是redis在某个时间点的数据快照， 非常适合用于数据备份，全量复制等场景

3. RDB恢复数据的速度要比AOF快很多

   

##### 缺点

1. RDB方式无论是执行指令还是利用配置，**无法做到实时持久化**，具有较大的可能性丢失数据，宕机带来的数据丢失风险 

2. bgsave指令每次运行要执行fork操作创建子进程， 要牺牲掉一些性能

3. **Redis的众多版本中未进行RDB文件格式的版本统一，**有可能出现各版本服务之间数据格式无法兼容现象 

4. 存储数据量较大，效率较低 （基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 ）

   

##### 应用

服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 







### AOF

以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。 

AOF的主要作用是解决了**数据持久化的实时性**，目前已经是**Redis持久化的主流方式** 



#### AOF写数据的三种策略

![1609740616463](.\images\1609740616463.png)



#### AOF功能开启

![1609740694298](.\images\1609740694298.png)





相关配置

![1609740756413](.\images\1609740756413.png)





#### 写数据时遇到的问题

![1609740876867](C:\Users\jin.zhang\Desktop\笔记\我的笔记\images\1609740876867.png)





#### AOF重写



随着命令不断写入AOF，文件会越来越大，为了解决这个问题， Redis引入了AOF重写机制**压缩文件体积**。

 AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。 简单说就是**将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录**。 



##### 作用

1. 降低磁盘占用量，提高磁盘利用率 
2. 提高持久化效率，降低持久化写时间，提高IO性能 
3. 降低数据恢复用时，提高数据恢复效率 



##### 规则

1. 进程内已超时的数据不再写入文件 
2. 忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令 

> 如del key1、 hdel key2、 srem key3、 set key4 111、 set key4 222等 

3. 对同一数据的多条写命令合并为一条命令 

> 如lpush list1 a、 lpush list1 b、 lpush list1 c 可以转化为： lpush list1 a b c。
> 为防止数据量过大造成客户端缓冲区溢出，对list、 set、 hash、 zset等类型， 每条指令最多写入64个元素 



##### 重写方式

![1609741217738](.\images\1609741217738.png)

AOF手动重写bgrewriteaof指令工作原理 

![1609741389899](.\images\1609741389899.png)

自动重写

![1609741450794](.\images\1609741450794.png)



### RBD与AOF区别

##### 如何选择？

![1609741964102](.\images\1609741964102.png)



### Redis应用场景

![1609742606910](.\images\1609742606910.png)

















## 删除策略

![1609744484535](.\images\1609744484535.png)



#### 三种策略

##### 1. 定时删除

![1609744979132](.\images\1609744979132.png)

##### 2. 惰性删除

![1609745021406](C:\Users\jin.zhang\Desktop\笔记\我的笔记\images\1609745021406.png)

##### 3. 定期删除

![1609745192662](.\images\1609745192662.png)

![1609745221172](.\images\1609745221172.png)





#### 时效性数据存储结构

![1609744612743](.\images\1609744612743.png)

#### 数据删除策略的目标 

在**内存**占用与**CPU**占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 。

















## 逐出算法

当新数据进入redis时，如果内存不足怎么办？ 

![1609745349335](.\images\1609745349335.png)



...详见pdf



















## Redis服务器配置

![1609746017850](.\images\1609746017850.png)

![1609746272297](.\images\1609746272297.png)

![1609746338332](.\images\1609746338332.png)

![1609746614851](.\images\1609746614851.png)

















## 主从复制（高可用）

为了避免单点Redis服务器故障，准备多台服务器，互相连通。 将数据复制多个副本保存在不同的服
务器上， 连接在一起， 并保证数据是同步的。 即使有其中一台服务器宕机，其他服务器依然可以继续
提供服务，实现Redis的高可用， 同时实现数据冗余备份。 	



主从复制即将master中的数据即时、有效的复制到slave中 

特征：一个master可以拥有多个slave，一个slave只对应一个master 

- master:
  写数据
  执行写操作时，将出现变化的数据自动同步到slave
  读数据（可忽略）
- slave:
  读数据
  写数据（禁止） 

#### 作用

读写分离： master写、 slave读，提高服务器的读写负载能力 

负载均衡： 由slave分担master负载，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 

故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 

数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 

高可用基石： 基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 





















# 企业级解决方案



## 缓存预热

针对情况：服务器启动后迅速宕机 

问题排查：

1. 请求数量较高
2. 主从之间数据吞吐量较大，数据同步操作频度较高

#### 解决方案

前置准备工作：
1. 日常例行统计数据访问记录，统计访问频度较高的热点数据

2. 利用LRU数据删除策略，构建数据留存队列
  例如： storm与kafka配合

  

  准备工作：

3. 将统计结果中的数据分类，根据级别， redis优先加载级别较高的热点数据

4. 利用分布式多服务器同时进行数据读取， 提速数据加载过程

5. 热点数据主从同时预热

  

  实施：

6. 使用脚本程序固定触发数据预热过程

7. 如果条件允许， 使用了CDN（内容分发网络），效果会更好 

#### 总结

缓存预热就是系统启动前， 提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 







## 缓存雪崩

#### 出现情况

1. 系统平稳运行过程中，忽然数据库连接量激增
2. 应用服务器无法及时处理请求
3. 大量408， 500错误页面出现
4. 客户反复刷新页面获取数据
5. 数据库崩溃
6. 应用服务器崩溃
7. 重启应用服务器无效
8. Redis服务器崩溃
9. Redis集群崩溃
10. 重启数据库后再次被瞬间流量放倒 



#### 问题排查

1. 在一个较短的时间内，**缓存中较多的key集中过期**
2. 此周期内请求访问过期的数据， redis未命中， redis向数据库获取数据
3. 数据库同时接收到大量的请求无法及时处理
4. Redis大量请求被积压，开始出现超时现象
5. 数据库流量激增，数据库崩溃
6. 重启后仍然面对缓存中无数据可用
7. Redis服务器资源被严重占用， Redis服务器崩溃
8. Redis集群呈现崩塌，集群瓦解
9. 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃
10. 应用服务器， redis，数据库全部重启，效果不理想 



#### 问题分析

短时间范围内，大量key集中过期



#### 解决方案

1. 更多的页面静态化处理
2. 构建多级缓存架构
  Nginx缓存+redis缓存+ehcache缓存
3. 检测Mysql严重耗时业务进行优化
  对数据库的瓶颈排查：例如超时查询、耗时较高事务等
4. 灾难预警机制
  监控redis服务器性能指标
   CPU占用、 CPU使用率
   内存容量
   查询平均响应时间
   线程数
5. 限流、降级
  短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 



#### 总结

缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整 。





## 缓存击穿

#### 问题排查

1. Redis中某个key过期，该key访问量巨大
2. 多个数据请求从服务器直接压到Redis后，均未命中
3. Redis在短时间内发起了大量对数据库中**同一数据**的访问 



#### 问题分析

单个key高热数据 ，key过期



#### 解决方案

1. 预先设定
  以电商为例，每个商家根据店铺等级， 指定若干款主打商品，在购物节期间， 加大此类信息key的过期时长
  注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势
2. 现场调整
  监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key
3. 后台刷新数据
  启动定时任务，高峰期来临之前， 刷新数据有效期， 确保不丢失
4. 二级缓存
  设置不同的失效时间，保障不会被同时淘汰就行
5. 加锁
  分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！ 



#### 总结

缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。 





## 缓存穿透



#### 出现情况

1. 系统平稳运行过程中
2. 应用服务器流量随时间增量较大
3. Redis服务器命中率随时间逐步降低
4. Redis内存平稳，内存无压力
5. Redis服务器CPU占用激增
6. 数据库服务器压力激增
7. 数据库崩溃 



#### 问题排查

1. Redis中大面积出现未命中
2. 出现非正常URL访问 



#### 问题分析

 获取的数据在数据库中也不存在，数据库查询未得到对应数据
 Redis获取到null数据未进行持久化，直接返回
 下次此类数据到达重复上述过程
 出现黑客攻击服务器 



#### 解决方案

1. 缓存null
  对查询结果为null的数据进行缓存（长期使用，定期清理）， 设定短时限，例如30-60秒， 最高5分钟
2. 白名单策略
   提前预热各种分类数据id对应的bitmaps， id作为bitmaps的offset，相当于设置了数据白名单。 当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）
   使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）
3. 实施监控
  实时监控redis命中率（ 业务正常范围时，通常会有一个波动值）与null数据的占比
   非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象
   活动时段波动：通常检测10-50倍， 超过50倍纳入重点排查对象
  根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）
4. key加密
  问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验
  例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问 



#### 总结

缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。 