Java中每种基本类型所占用的存储空间是固定的，不像其他语言随着机器硬件架构的变化而变化，这也是Java程序比其他大多数语言更具可移植性的原因。

char在Java中占用两个字节


方法的签名：方法名+参数类型。

注意：返回值不是方法签名的一部分，所以两个方法 方法签名相同，但返回值不同，则不能重载



多态
所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。 



**String 为什么是不可变的?**

 String 类中使⽤ final 关键字修饰字符数组来保存字符串， private final char
value[] ，所以 String 对象是不可变的。
补充（来⾃issue 675）：在 Java 9 之后， String 类的实现改⽤ byte 数组存储字符串
private final byte[] value

**String StringBuffer 和 StringBuilder 的区别是什么? **
可变性
StringBuilder 与 StringBuffer 的构造⽅法都是调⽤⽗类构造⽅法也就是 AbstractStringBuilder
实现的，⼤家可以⾃⾏查阅源码。
AbstractStringBuilder.java
线程安全性
**String** 中的对象是不可变的，也就可以理解为常量，**线程安全**。 AbstractStringBuilder 是StringBuilder 与 StringBuffer 的公共⽗类，定义了⼀些字符串的基本操作，如 expandCapacity、append、 insert、 indexOf 等公共⽅法。 **StringBuffer** 对⽅法加了同步锁或者对调⽤的⽅法加了同步锁，所以是**线程安全**的。 **StringBuilder** 并没有对⽅法进⾏加同步锁，所以是**⾮线程安全**的。
性能

每次对 String 类型进⾏改变的时候，都会⽣成⼀个新的 String 对象，然后将指针指向新的 String对象。 StringBuffer 每次都会对 StringBuffer 对象本身进⾏操作，⽽不是⽣成新的对象并改变对象引⽤。相同情况下使⽤ StringBuilder 相⽐使⽤ StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的⻛险。
对于三者使⽤的总结：

1. 操作少量的数据: 适⽤ String
2. 单线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuilder
3. 多线程操作字符串缓冲区下操作⼤量数据: 适⽤ StringBuffer 



如果定义了带有参数的构造函数，则默认构造函数失效

原来的默认函数（没有参数的默认函数）需手动定义



26. == 与 equals(重要)
    de : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型
    WX⽐较的是值，引⽤数据类型WX⽐较的是内存地址)。
    equals() : 它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：
    情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐较该类的两个对象时，等价于通过
    “WX”⽐较这两个对象。
    情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐较两个对象的内容是
    否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 
27. 说明：
    String 中的 equals ⽅法是被重写过的，因为 object 的 equals ⽅法是⽐较的对象的内存地
    址，⽽ String 的 equals ⽅法⽐较的是对象的值。
    当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同
    的对象，如果有就把它赋给当前引⽤。如果没有就在常量池中重新创建⼀个 String 对象。 

27. hashCode 与 equals (重要)
    ⾯试官可能会问你： “你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode
    ⽅法？ ”
    hashCode（）介绍
    hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数。这个哈希码的作⽤
    是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java
    中的任何类都包含有 hashCode() 函数。
    散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利
    ⽤到了散列码！（可以快速找到所需要的对象）
    为什么要有 hashCode
    我们先以“HashSet 如何检查重复”为例⼦来说明为什么要有 hashCode： 当你把对象加⼊ HashSet
    时， HashSet 会先计算对象的 hashcode 值来判断对象加⼊的位置，同时也会与该位置其他已经加⼊的
    对象的 hashcode 值作⽐较，如果没有相符的 hashcode， HashSet 会假设对象没有重复出现。但是如
    果发现有相同 hashcode 值的对象，这时会调⽤ equals() ⽅法来检查 hashcode 相等的对象是否真
    的相同。如果两者相同， HashSet 就不会让其加⼊操作成功。如果不同的话，就会重新散列到其他位
    置。（摘⾃我的 Java 启蒙书《Head first java》第⼆版）。这样我们就⼤⼤减少了 equals 的次
    数，相应就⼤⼤提⾼了执⾏速度。
    通过我们可以看出： hashCode() 的作⽤就是获取哈希码，也称为散列码；它实际上是返回⼀个 int
    整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置。 hashCode() 在散列表中才有⽤，在
    其它情况下没⽤。在散列表中 hashCode() 的作⽤是获取对象的散列码，进⽽确定该对象在散列表中的
    位置。
    hashCode（）与 equals（）的相关规定
28. 如果两个对象相等，则 hashcode ⼀定也是相同的
29. 两个对象相等,对两个对象分别调⽤ equals ⽅法都返回 true
30. 两个对象有相同的 hashcode 值，它们也不⼀定是相等的
31. 因此， equals ⽅法被覆盖过，则 hashCode ⽅法也必须被覆盖
32. hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode()，则该 class
   的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）
   推荐阅读： Java hashCode() 和 equals()的若⼲问题解答 



30. **线程有哪六种基本状态?** 

线程创建之后它将处于 **NEW**（新建） 状态，调⽤ start() ⽅法后开始运⾏，线程这时候处于
READY（可运⾏） 状态。可运⾏状态的线程获得了 cpu 时间⽚（timeslice）后就处于 RUNNING（运
⾏） 状态。 

操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（，所以 Java 系统⼀般将这两个状态统称为 **RUNNABLE**（运⾏中） 状态 。 

当线程执⾏ wait() ⽅法之后，线程进⼊ **WAITING**（等待） 状态。进⼊等待状态的线程需要依靠其他
线程的通知才能够返回到运⾏状态，⽽ **TIME_WAITING**(超时等待) 状态相当于在等待状态的基础上增加
了超时限制，⽐如通过 sleep（long millis） ⽅法或 wait（long millis） ⽅法可以将 Java
线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调
⽤同步⽅法时，在没有获取到锁的情况下，线程将会进⼊到 **BLOCKED（**阻塞） 状态。线程在执⾏
Runnable 的 run() ⽅法之后将会进⼊到 **TERMINATED**（终⽌） 状态 





**Java 中 IO 流分为⼏种?**
按照流的流向分，可以分为输⼊流和输出流；
按照操作单元划分，可以划分为字节流和字符流；
按照流的⻆⾊划分为节点流和处理流。
Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，⽽且彼此之间存在
的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派⽣出来的。
InputStream/Reader: 所有的输⼊流的基类，前者是字节输⼊流，后者是字符输⼊流。
OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 





**BIO,NIO,AIO 有什么区别?**
BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写⼊必须阻塞在⼀个线程内等待其完
成。在活动连接数不是特别⾼（⼩于单机 1000）的情况下，这种模型是⽐较不错的，可以让每
⼀个连接专注于⾃⼰的 I/O 并且编程模型简单，也不⽤过多考虑系统的过载、限流等问题。线
程池本身就是⼀个天然的漏⽃，可以缓冲⼀些系统处理不了的连接或请求。但是，当⾯对⼗万甚
⾄百万级连接的时候，传统的 BIO 模型是⽆能为⼒的。因此，我们需要⼀种更⾼效的 I/O 处理
模型来应对更⾼的并发量。
NIO (Non-blocking/New I/O): NIO 是⼀种同步⾮阻塞的 I/O 模型，在 Java 1.4 中引⼊了
NIO 框架，对应 java.nio 包，提供了 Channel , Selector， Buffer 等抽象。 NIO 中的 N 可
以理解为 Non-blocking，不单纯是 New。它⽀持⾯向缓冲的，基于通道的 I/O 操作⽅法。 NIO
提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和
ServerSocketChannel 两种不同的套接字通道实现,两种通道都⽀持阻塞和⾮阻塞两种模
式。阻塞模式使⽤就像传统中的⽀持⼀样，⽐较简单，但是性能和可靠性都不好；⾮阻塞模式正
好与之相反。对于低负载、低并发的应⽤程序，可以使⽤同步阻塞 I/O 来提升开发速率和更好
的维护性；对于⾼负载、⾼并发的（⽹络）应⽤，应使⽤ NIO 的⾮阻塞模式来开发
AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引⼊了 NIO 的改进版 NIO 2,它是
异步⾮阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应⽤操作之后会直接返
回，不会堵塞在那⾥，当后台处理完成，操作系统会通知相应的线程进⾏后续的操作。 AIO 是异
步 IO 的缩写，虽然 NIO 在⽹络操作中，提供了⾮阻塞的⽅法，但是 NIO 的 IO ⾏为还是同步
的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程⾃
⾏进⾏ IO 操作， IO 操作本身是同步的。查阅⽹上相关资料，我发现就⽬前来说 AIO 的应⽤还
不是很⼴泛， Netty 之前也尝试使⽤过 AIO，不过⼜放弃了。 



**2.2.15 如何选⽤集合?**
主要根据集合的特点来选⽤，⽐如我们需要根据键值获取到元素值时就选⽤Map接⼝下的集合，需要排
序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选⽤ConcurrentHashMap.当我们只
需要存放元素值时，就选择实现Collection接⼝的集合，需要保证元素唯⼀时选择实现Set接⼝的集合
⽐如TreeSet或HashSet，不需要就选择实现List接⼝的⽐如ArrayList或LinkedList，然后再根据实现
这些接⼝的集合的特点来选⽤。 



程序计数器为什么是私有的?
程序计数器主要有下⾯两个作⽤：
1. 字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执⾏、
  选择、循环、异常处理。
2. 在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时候能
  够知道该线程上次运⾏到哪⼉了。
  需要注意的是，如果执⾏的是 native ⽅法，那么程序计数器记录的是 undefined 地址，只有执⾏的
  是 Java 代码时程序计数器记录的才是下⼀条指令的地址。
  所以，程序计数器私有主要是为了线程切换后能恢复到正确的执⾏位置。





虚拟机栈和本地⽅法栈为什么是私有的?
虚拟机栈： 每个 Java ⽅法在执⾏的同时会创建⼀个栈帧⽤于存储局部变量表、操作数栈、常
量池引⽤等信息。从⽅法调⽤直⾄执⾏完成的过程，就对应着⼀个栈帧在 Java 虚拟机栈中⼊栈
和出栈的过程。
本地⽅法栈： 和虚拟机栈所发挥的作⽤⾮常相似，区别是： 虚拟机栈为虚拟机执⾏ Java ⽅法
（也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。 在 HotSpot 虚
拟机中和 Java 虚拟机栈合⼆为⼀。
所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地⽅法栈是线程私有的 